# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kwhmyqXC9BhPNKaLmP5CbYK-hSNnpLrK

# Segmentation d'Image :
Code basé sur OpenCV: Il s'agit d'une méthode classique de traitement d'image fournies par OpenCV. Cette méthode sépare les pixels d'une image en deux groupes (objet et fond) selon une valeur de seuil. Ici, un seuil fixe est utilisé : cv2.threshold.
"""

# Importation des bibliothèques nécessaires
from google.colab import files
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Commencer par télécharger l'image
print("Téléchargez une image pour la segmentation :")
uploaded = files.upload()

# Obtenir le nom du fichier téléchargé
image_path = list(uploaded.keys())[0]
print(f"L'image téléchargée est : {image_path}")

# Charger l'image
image = cv2.imread(image_path)
if image is None:
    raise FileNotFoundError(f"L'image spécifiée est introuvable : {image_path}")

# Convertir en format RGB
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Initialiser le masque pour GrabCut
mask = np.zeros(image.shape[:2], dtype=np.uint8)

# Rectangle approximant l'objet
height, width = image.shape[:2]
rect = (10, 10, width - 20, height - 20)

# Initialiser les modèles (nécessaires pour GrabCut)
bgd_model = np.zeros((1, 65), dtype=np.float64)
fgd_model = np.zeros((1, 65), dtype=np.float64)

# Appliquer GrabCut
cv2.grabCut(image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)

# Convertir le masque en binaire
mask_binary = np.where((mask == 2) | (mask == 0), 0, 1).astype(np.uint8)

# Appliquer le masque à l'image originale
background_removed = cv2.bitwise_and(image_rgb, image_rgb, mask=mask_binary)

# Ajouter une couche alpha pour le fond transparent
result = cv2.cvtColor(background_removed, cv2.COLOR_RGB2RGBA)
result[:, :, 3] = mask_binary * 255  # Transparence basée sur le masque

# Créer un fond coloré (par exemple, bleu clair)
background_color = (135, 206, 235)  # Bleu clair
colored_background = np.full_like(image_rgb, background_color, dtype=np.uint8)

# Superposer l'image segmentée sur le fond coloré
alpha = mask_binary[:, :, None]  # Ajouter une dimension pour le canal alpha
colored_result = (background_removed * alpha + colored_background * (1 - alpha)).astype(np.uint8)

# Afficher les résultats
plt.figure(figsize=(15, 10))

# Image originale
plt.subplot(1, 3, 1)
plt.title("Image Originale")
plt.imshow(image_rgb)
plt.axis("off")

# Image segmentée avec fond transparent
plt.subplot(1, 3, 2)
plt.title("Image Segmentée (Fond Transparent)")
plt.imshow(result)
plt.axis("off")

# Image segmentée sur fond coloré
plt.subplot(1, 3, 3)
plt.title("Image Segmentée (Fond Coloré)")
plt.imshow(colored_result)
plt.axis("off")

plt.show()

# Optionnel : Sauvegarder les résultats
output_path_transparent = "result_transparent.png"
output_path_colored = "result_colored.png"
cv2.imwrite(output_path_transparent, cv2.cvtColor(result, cv2.COLOR_RGBA2BGRA))
cv2.imwrite(output_path_colored, cv2.cvtColor(colored_result, cv2.COLOR_RGB2BGR))
print(f"L'image segmentée avec fond transparent a été sauvegardée à : {output_path_transparent}")
print(f"L'image segmentée avec fond coloré a été sauvegardée à : {output_path_colored}")

"""**Pour télécharger l'image segmentée**"""

from google.colab import files
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Télécharger l'image
print("Téléchargez une image pour la segmentation :")
uploaded = files.upload()

# Obtenir le nom du fichier téléchargé
image_path = list(uploaded.keys())[0]
print(f"L'image téléchargée est : {image_path}")

# Charger l'image
image = cv2.imread(image_path)
if image is None:
    raise FileNotFoundError(f"L'image spécifiée est introuvable : {image_path}")

# Convertir en format RGB
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Initialiser le masque pour GrabCut
mask = np.zeros(image.shape[:2], dtype=np.uint8)

# Rectangle approximant l'objet
height, width = image.shape[:2]
rect = (10, 10, width - 20, height - 20)

# Initialiser les modèles (nécessaires pour GrabCut)
bgd_model = np.zeros((1, 65), dtype=np.float64)
fgd_model = np.zeros((1, 65), dtype=np.float64)

# Appliquer GrabCut
cv2.grabCut(image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)

# Convertir le masque en binaire
mask_binary = np.where((mask == 2) | (mask == 0), 0, 1).astype(np.uint8)

# Appliquer le masque à l'image originale
background_removed = cv2.bitwise_and(image_rgb, image_rgb, mask=mask_binary)

# Ajouter un canal alpha pour le fond transparent
result = cv2.cvtColor(background_removed, cv2.COLOR_RGB2RGBA)
result[:, :, 3] = mask_binary * 255  # Transparence basée sur le masque

# Découper l'image pour ne conserver que l'objet
coords = cv2.findNonZero(mask_binary)  # Trouver les pixels non nuls (objet)
x, y, w, h = cv2.boundingRect(coords)  # Obtenir un rectangle englobant
cropped_result = result[y:y+h, x:x+w]  # Découper l'image

# Sauvegarder l'image segmentée sans fond
output_path_object = "object_segmented.png"
cv2.imwrite(output_path_object, cv2.cvtColor(cropped_result, cv2.COLOR_RGBA2BGRA))

print(f"L'image segmentée sans fond a été sauvegardée à : {output_path_object}")

# Afficher le résultat final
plt.figure(figsize=(8, 8))
plt.title("Objet Segmenté (Sans Fond)")
plt.imshow(cropped_result)
plt.axis("off")
plt.show()